"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _ = require("lodash");
var Bluebird = require("bluebird");
var Brakes = require("brakes");
var grpc = require("grpc");
var protoLoader = require("@grpc/proto-loader");
var debug = require("debug");
var metrics_1 = require("./metrics");
var brake_1 = require("./brake");
var interceptor_1 = require("./interceptor");
var health_1 = require("./health");
var log = debug('grpcHelper:client');
Promise = Bluebird;
var HelperClientCreator = /** @class */ (function () {
    function HelperClientCreator(opts) {
        this.methodNames = [];
        this.opts = opts;
        this.setupGRPCCredentials();
        this.setupGRPCOpts();
        this.setupSvcDefs();
    }
    HelperClientCreator.prototype.getMethodNames = function () {
        return this.methodNames;
    };
    HelperClientCreator.prototype.setupSvcDefs = function () {
        var _this = this;
        var _a = this.opts, pkg = _a.packageName, svc = _a.serviceName, opts = _a.grpcProtoLoaderOpts;
        var packageDefinition = protoLoader.loadSync(this.opts.protoPath, opts);
        this.Service = _.get(grpc.loadPackageDefinition(packageDefinition), pkg + "." + svc);
        this.serviceDefinition = packageDefinition[pkg + "." + svc];
        _.each(this.serviceDefinition, function (md, methodName) {
            _this.methodNames.push(methodName);
            if (md.originalName) {
                _this.methodNames.push(md.originalName);
            }
            if (md.responseStream) {
                return;
            }
            // keep callback style call
            var callbackMethod = "cb" + methodName;
            _this.methodNames.push(callbackMethod);
        });
        return this.methodNames;
    };
    HelperClientCreator.prototype.setupGRPCCredentials = function () {
        if (this.opts.sslOpts && this.opts.sslOpts.enable) {
            log('ssl enabled %s.%s', this.opts.packageName, this.opts.serviceName);
            var _a = this.opts.sslOpts, cacert = _a.cacert, cert = _a.cert, key = _a.key;
            this.grpcCredentials = grpc.credentials.createSsl(cacert, cert, key);
        }
        else {
            log('ssl disabled %s.%s', this.opts.packageName, this.opts.serviceName);
            this.grpcCredentials = grpc.credentials.createInsecure();
        }
    };
    HelperClientCreator.prototype.setupGRPCOpts = function () {
        this.grpcOpts = this.opts.grpcOpts || {};
        if (this.opts.hostNameOverride) {
            log('override hostname %s', this.opts.hostNameOverride);
            this.grpcOpts = _.extend(this.grpcOpts, {
                'grpc.ssl_target_name_override': this.opts.hostNameOverride,
                'grpc.default_authority': this.opts.hostNameOverride,
            });
        }
        var _a = this.opts, timeoutInMS = _a.timeoutInMS, metrics = _a.metrics;
        this.grpcOpts.interceptors = this.grpcOpts.interceptors || [];
        if (metrics) {
            log('enable metrics');
            this.grpcOpts.interceptors.push(metrics_1.getMetricsInterceptor());
        }
        if (timeoutInMS) {
            log('enable global timeout: %d ms', timeoutInMS);
            this.grpcOpts.interceptors.push(interceptor_1.getDeadlineInterceptor(timeoutInMS));
        }
    };
    HelperClientCreator.prototype.getBrake = function (pkg, svc, host) {
        var name = pkg + "." + svc;
        var brakeOpts = {
            name: name + "-" + host + "-brake",
            healthCheck: null,
        };
        if (this.opts.healthCheck.enable) {
            brakeOpts.healthCheck = health_1.getBrakeHealthCheckFunc(name, host, {
                timeoutInMS: this.opts.healthCheck.timeoutInMS,
                grpcCredentials: this.grpcCredentials,
                grpcOpts: this.grpcOpts,
            });
        }
        return new Brakes(Object.assign(brakeOpts, this.opts.brakeOpts));
    };
    HelperClientCreator.prototype.closeClient = function (client) {
        client.connected = false;
        client.grpcClient.close();
        client.grpcClient = null;
    };
    HelperClientCreator.prototype.createClient = function (host) {
        log('Setup client for %s', host);
        var _a = this.opts, pkg = _a.packageName, svc = _a.serviceName, resolveFullResponse = _a.resolveFullResponse;
        var grpcClient = new this.Service(host, this.grpcCredentials, this.grpcOpts);
        var brake = this.getBrake(pkg, svc, host);
        var client = {
            address: host,
            grpcClient: grpcClient,
            brake: brake,
            connected: true,
        };
        _.each(this.serviceDefinition, function (md, method) {
            var methodCall = grpcClient[method].bind(grpcClient);
            // only deal with call with callback
            if (md.responseStream) {
                client[method] = methodCall;
                if (md.originalName) {
                    client[md.originalName] = methodCall;
                }
                return;
            }
            // keep callback style call
            var callbackMethod = "cb" + method;
            client[callbackMethod] = methodCall;
            // Start promisify and add brake for call with callback
            function wrappedMethodCall(data) {
                if (data === void 0) { data = {}; }
                var args = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    args[_i - 1] = arguments[_i];
                }
                var isStream = _.isFunction(data.read) && _.isFunction(data.on);
                var call;
                var message = new Promise(function (resolve, reject) {
                    if (isStream) {
                        call = methodCall.apply(void 0, args.concat([function (err, rst) {
                                if (err)
                                    return reject(err);
                                resolve(rst);
                            }]));
                        data.pipe(call);
                        return;
                    }
                    call = methodCall.apply(void 0, [data].concat(args, [function (err, rst) {
                            if (err)
                                return reject(err);
                            resolve(rst);
                        }]));
                });
                if (!resolveFullResponse) {
                    return message;
                }
                // Resolve with full response
                return Promise.props({
                    metadata: new Promise(function (resolve) { return call.on('metadata', resolve); }),
                    status: new Promise(function (resolve) { return call.on('status', resolve); }),
                    message: message,
                    peer: call.getPeer(),
                });
            }
            client[method] = brake_1.wrapWithBrake(wrappedMethodCall, brake);
            if (md.originalName) {
                client[md.originalName] = client[method];
            }
        });
        return client;
    };
    return HelperClientCreator;
}());
exports.HelperClientCreator = HelperClientCreator;
//# sourceMappingURL=client.js.map